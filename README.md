# 프로젝트를 통해 느낀점: 협업의 본질

## 프로젝트 구상 배경: 기술 스택을 넘어선 협업

본 오픈 미션을 구상할 때, 저는 비전공자로서 부트캠프에서 자바만을 다루었던 경험에 갇혀 도메인 설정에 막막함을 느꼈습니다. 하지만 고민을 '어떤 서비스를 만들까'에서 **'실제로 내가 개발팀에 합류한다면 어떻게 일할까'**로 전환했습니다.
저는 자바 개발자로 취업하겠지만, 결국 팀은 코틀린, 파이썬 등 이질적인 스택을 가진 동료들과 **협업**해야 합니다. 따라서 기술 스택의 문법을 깊이 알기보다, **다른 개발자가 어떤 언어로 프로젝트의 어떤 역할을 구현하는지**에 대한 설계적 이해가 선행되어야 한다고 판단했습니다.
이번 과제는 도메인을 완전히 배제하고, **한 프로젝트 내에서 자바, 코틀린, 파이썬 개발자가 있을 경우 소통과 역할 분담의 기준**을 학습하는 데 집중했습니다.

## 협업의 핵심: API 계약과 설계 책임 이해

이 프로젝트를 통해 명확히 깨달은 바는 다음과 같습니다.

1.  **협업의 최소 단위는 'API 계약'이다:**
    * 개발자는 각자 특정한 목적을 가진 API를 만들고, 이 **API의 엔드포인트, 포트, 응답 형식(JSON Schema)**을 통해 소통합니다. 상대방의 내부 코드는 알 필요가 없으며, **협의된 형식으로 응답을 반환하는 것**이 최우선 책임이 됩니다.

2.  **설계 단계에서 통합 목표를 명확히 이해해야 한다:**
    * 자바 개발자는 **오케스트레이터로서의 책임**을 이해하고, 다른 서비스의 장애에 대비해 `try-catch`로 방어적인 호출 로직을 구현해야 했습니다.
    * 코틀린 개발자는 **핵심 데이터 제공자로서의 성능 책임**을, 파이썬 개발자는 **일관된 형식의 데이터 응답 책임**을 집니다. 내가 구현하는 역할이 전체 프로젝트의 최종 목표에서 어떤 영향을 미치는지 이해하는 것이 가장 중요했습니다.

## 마치며

이 프로젝트는 코드는 짧지만, **'기술을 써보는 것'보다 '일을 한다'는 개발자의 본질적인 개념**에 집중하고자 했습니다.
앞으로의 개발자 커리어는 정해진 도메인과 아키텍처 내에서, 기술 스택을 넘어선 **소통과 설계 이해 능력**이 핵심 역량이라고 확신합니다. 이 프로젝트는 그 역량을 위한 첫 훈련이었습니다.

***

## 1. 프로젝트 개요 (Overview)

본 프로젝트는 각 비즈니스 역할에 최적화된 언어(Java, Kotlin, Python)를 선택하여 **다국어 마이크로서비스 아키텍처(Polyglot MSA)**의 구축 및 서비스 간 통신 구조를 학습하고 시연하기 위해 구현되었습니다.
이는 안정성과 유연성을 동시에 확보하는 것을 목표로 합니다.

***

## 2. 설계 및 아키텍처

### 2-1. 아키텍처 패턴: 오케스트레이터 기반 통합 (Orchestrator Pattern)

모든 서비스는 독립적인 포트에서 실행되며, **Java `auth-service`**가 **오케스트레이터(Orchestrator)** 역할을 수행합니다.
이 메인 서비스는 외부 요청을 받아 Kotlin 및 Python 서비스들을 호출하고 데이터를 병합(Aggregation)하여 최종 응답을 제공합니다.

### 2-2. 서비스 구성 및 역할

| 서비스 (모듈) | 언어 / 프레임워크 | 포트 | 주요 역할 |
| :--- | :--- | :--- | :--- |
| **`auth-service`** | Java / Spring Boot | 8080 | 게이트웨이 및 통합 관리. (Main Server) |
| **`content-service`** | Kotlin / Spring Boot | 8081 | 핵심 비즈니스 로직. (콘텐츠 데이터 제공) |
| **`recommender-service`** | Python / FastAPI | 8082 | 특화 기능. (AI 추천 태그 제공) |

### 2-3. 통신 방식

Java `auth-service`는 **`RestTemplate`**을 사용하여 Kotlin 및 Python 서비스의 API 엔드포인트에 **HTTP REST 호출**을 수행하며 **동기(Synchronous) 통신** 구조를 시연합니다.

***

## 3. 구현 및 실행 환경

### 3-1. 기술 스택

* **언어:** Java 21, Kotlin 2.0.0, Python 3.10+
* **프레임워크:** Spring Boot 3.x, FastAPI
* **빌드 도구:** Gradle, venv/pip

### 3-2. 로컬 실행 방법

1.  **환경 준비:** Java 21 및 Python 환경을 확인하고 IntelliJ IDEA에서 `open-mission` 프로젝트를 엽니다.
2.  **순차적 서비스 실행:** 다음 세 서비스를 순서대로 실행합니다.
    * `recommender-service` (Python: `main.py` 실행)
    * `content-service` (Kotlin: Application 파일 실행)
    * `auth-service` (Java: Application 파일 실행)
3.  **최종 확인:** 브라우저에서 `http://localhost:8080/dashboard` 접속 후, 통합된 JSON 응답을 확인합니다.

***

## 4. 학습 성과 및 개선 방향

### 4-1. 주요 학습 성과

* **MSA 통신 이해:** Java 오케스트레이터가 Kotlin 및 Python 서버를 **REST 호출**하여 데이터를 수신하고 병합하는 **통합 로직**을 구현했습니다.
* **다국어 환경 관리:** 서로 다른 빌드 시스템(Gradle, venv/pip)을 하나의 **Monorepo** 구조 내에서 성공적으로 관리했습니다.
* **생산성 경험:** Kotlin의 **`data class`** 등 간결한 언어 문법과 FastAPI의 경량 서버 구축을 통해 언어별 특장점을 체감했습니다.

### 4-2. 향후 개선 방향

* **비동기 통신 도입:** 서비스 간 결합도를 낮추기 위해 REST 호출 대신 메시지 큐(Kafka 등)를 활용한 **이벤트 기반 비동기 통신**으로의 전환을 고려합니다.
* **서비스 디스커버리:** 하드코딩된 포트 대신, **Eureka** 같은 도구를 도입하여 서비스의 위치를 동적으로 관리하는 **서비스 디스커버리** 기능을 추가합니다.
